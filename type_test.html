<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêª BearPaw Type Scorer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêª</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #2a2a2a;
            color: #fff;
            font-family: 'Courier New', monospace;
            padding: 20px;
            /* NEW: Enable smooth scrolling and hide horizontal overflow */
            overflow-x: hidden; 
            transition: background 0.8s ease-in-out; 
            /* MODIFIED: Ensure body is scroll-blocked by default */
            overflow-y: hidden;
            height: 100vh;
        }

        /* NEW: Scroll block class - primary control */
        body.scroll-blocked {
            overflow: hidden !important;
        }
        
        /* NEW: Mode after test is closed (allows scrolling to dashboard) */
        body.goodbye-mode {
            overflow-y: auto !important;
            height: auto; /* Allows document height to expand and scroll normally */
            background: #1a1a1a;
        }

        /* MODIFIED: The main container gets the fly-away animation */
        @keyframes flyAway {
            0% { transform: translateY(0) rotateZ(0); opacity: 1; }
            100% { transform: translateY(-100vh) rotateZ(5deg); opacity: 0; }
        }
        
        .container.fly-away { /* Target the container, not the body */
            animation: flyAway 0.8s ease-in-out forwards;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 30px;
            /* NEW: Give container position for z-index management with the scrolling effect */
            position: relative;
            z-index: 100;
        }

        .main-section {
            flex: 1;
        }

        .sidebar {
            width: 300px;
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            max-height: 600px;
            overflow-y: auto;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #4a9eff;
        }

        /* Styling for the Timer Slider */
        .timer-setting {
            margin-bottom: 30px;
            padding: 10px 0;
        }
        
        .timer-setting label {
            display: block; 
            margin-bottom: 10px; 
            color: #aaa; 
            font-size: 1em;
        }
        
        #timerSlider {
            width: 100%; 
            -webkit-appearance: none; 
            appearance: none; 
            height: 10px; 
            background: #333; 
            border-radius: 5px;
            cursor: pointer;
        }
        
        #timerSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
            margin-top: -5px; 
        }
        
        #timerSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a9eff;
            cursor: pointer;
        }
        /* End of Timer Slider Styling */

        .speed-meter {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .speed-bar-container {
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin-bottom: 10px;
        }

        .speed-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #00ff88);
            width: 0%;
            transition: width 0.3s, background 0.3s;
            border-radius: 15px;
        }

        .speed-bar.burst {
            background: linear-gradient(90deg, #ff4444, #ffaa00, #ffff00);
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.2); }
        }

        .speed-message {
            text-align: center;
            font-size: 1.2em;
            color: #4a9eff;
            min-height: 30px;
            font-weight: bold;
        }

        .speed-message.burst {
            color: #ffaa00;
            animation: bounce 0.5s ease-in-out;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .stats {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            font-size: 1.2em;
        }

        .stat-item {
            background: #1a1a1a;
            padding: 15px 25px;
            border-radius: 8px;
        }

        .stat-label {
            color: #888;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            color: #4a9eff;
        }

        /* MODIFIED: Fixed height for typing area for consistent 3-line display */
        .typing-area {
            background: #1a1a1a;
            padding: 30px; 
            border-radius: 10px;
            font-size: 1.8em;
            line-height: 2.2;
            letter-spacing: 2px;
            margin-bottom: 30px;
            height: 180px; /* Fixed height for 3 lines of text */
            position: relative;
            overflow: hidden; 
        }

        .word {
            display: inline-block;
            margin-right: 12px;
        }

        .letter {
            color: #555;
            position: relative;
        }

        .letter.correct {
            color: #fff;
        }

        .letter.incorrect {
            color: #ff4444;
            background: #441111;
        }

        .letter.current::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 3px;
            background: #4a9eff;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .controls button {
            margin: 0 10px;
        }

        button {
            background: #4a9eff;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.3s;
        }

        button:hover {
            background: #357abd;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        /* History and Sidebar Styles (Existing) */
        .history-item {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .history-date {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .history-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.95em;
        }

        .history-wpm {
            color: #4a9eff;
            font-weight: bold;
        }

        .history-accuracy {
            color: #aaa;
        }

        h2 {
            margin-bottom: 20px;
            color: #4a9eff;
            font-size: 1.5em;
        }

        .no-history {
            color: #888;
            text-align: center;
            padding: 20px;
        }

        /* Username Modal (Existing) */
        .username-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .username-modal.hidden {
            display: none;
        }

        .username-form {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 400px;
        }
        
        /* Results Modal Styles */
        .results-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .results-modal.hidden {
            display: none;
        }

        .results-form {
            background: #1a1a1a;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 600px;
            width: 90%;
        }

        .results-form h2 {
            margin-bottom: 30px;
            font-size: 2.5em;
            color: #00ff88;
        }

        .results-form h3 {
            color: #4a9eff;
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .modal-stats {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-bottom: 20px;
        }

        .modal-stats .stat-item {
            background: #2a2a2a;
            padding: 20px 30px;
            border-radius: 10px;
            flex: 1;
            text-align: center;
        }

        .modal-stats .stat-value {
            font-size: 2.2em;
        }

        /* MODIFIED: Set fixed height for modal chart container to match historical chart */
        .chart-container-modal {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            height: 320px; /* NEW: Fixed height for chart area */
        }

        /* Modal Controls layout */
        .modal-controls {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .modal-controls button {
            flex: 1; 
            width: auto;
        }
        
        /* Style for the Close button */
        #closeResultsBtn {
            background: #555; 
        }
        
        #closeResultsBtn:hover {
            background: #777; 
        }
        
        /* NEW: Goodbye Message and Dashboard Area */
        .goodbye-dashboard-container {
            position: relative; 
            width: 100%;
            min-height: 100vh;
            display: none; /* Hide until activated */
            flex-direction: column;
            align-items: center;
            padding-top: 5vh; 
            text-align: center;
            background: #1a1a1a; /* Match sidebar/modal background */
            margin-top: -20px; /* Counteract initial body padding */
        }

        .goodbye-dashboard-container.active {
            display: flex;
        }

        #goodbyeText {
            font-size: 4em;
            color: #00ff88;
            font-weight: bold;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }
        
        .scroll-instruction {
            margin-bottom: 50px;
            font-size: 1.2em;
            color: #888;
        }

        /* MODIFIED: Limit width of the historical chart container to match modal width */
        .historical-chart-container {
            width: 90%; /* Match results-form width property */
            max-width: 600px; /* Match results-form max-width property */
            background: #2a2a2a;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 50px;
            height: 350px; /* NEW: Enforce a similar height (320px chart + 30px padding) */
        }
        
        .historical-chart-container h3 {
            color: #4a9eff;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        /* NEW: Ensure the canvas takes up the max available height within the fixed container */
        #historyChartCanvas {
            max-height: 100%;
        }

    </style>
</head>
<body class="scroll-blocked">
    <div class="username-modal" id="usernameModal">
        <div class="username-form">
            <h2>üêª Welcome to BearPaw Type!</h2>
            <p style="margin-bottom: 20px; color: #888;">Enter your username to get started</p>
            <input type="text" id="usernameInput" placeholder="Your username" maxlength="20">
            <button id="saveUsernameBtn">Start Typing!</button>
        </div>
    </div>

    <div class="results-modal hidden" id="resultsModal">
        <div class="results-form">
            <h2>‚úÖ Test Complete!</h2>
            <div class="modal-stats">
                <div class="stat-item">
                    <div class="stat-label">FINAL WPM</div>
                    <div class="stat-value" id="finalWPM">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">ACCURACY</div>
                    <div class="stat-value" id="finalAccuracy">100%</div>
                </div>
            </div>
            <div class="chart-container-modal">
                <h3>WPM Progression</h3>
                <canvas id="modalProgressChart"></canvas>
            </div>
            
            <div class="modal-controls">
                <button id="closeResultsBtn">Close</button>
                <button id="tryNextBtn">Try Next</button>
            </div>
        </div>
    </div>
    <div class="container" id="mainContainer">
        <div class="main-section">
            <h1>üêª BearPaw Type Scorer by VP</h1>
            
            <div class="timer-setting">
                <label for="timerSlider" id="timerLabel">Test Duration: 60s</label>
                <input type="range" id="timerSlider" min="15" max="120" value="60" step="5">
            </div>

            <div class="speed-meter">
                <div class="speed-bar-container">
                    <div class="speed-bar" id="speedBar"></div>
                </div>
                <div class="speed-message" id="speedMessage">Start typing to see your speed!</div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">TIME</div>
                    <div class="stat-value" id="timer">60</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">WPM</div>
                    <div class="stat-value" id="wpm">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">ACCURACY</div>
                    <div class="stat-value" id="accuracy">100%</div>
                </div>
            </div>

            <div class="typing-area" id="typingArea"></div>

            <div class="controls">
                <button id="restartBtn">Start Test</button>
            </div>
            
        </div>

        <div class="sidebar">
            <h2 id="sidebarTitle">Your Scores</h2>
            <div id="historyList"></div>
        </div>
    </div>
    
    <div class="goodbye-dashboard-container" id="goodbyeDashboardContainer">
        <h2 id="goodbyeText">SEE YOU LATER!</h2>
        <p class="scroll-instruction">(Return often hero your progress quest just keeps getting better!üöÄ)</p>
        
        <div class="historical-chart-container">
            <h3> WPM History</h3>
            <canvas id="historyChartCanvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        const words = ["the", "be", "to", "of", "and", "a", "in", "that", "have", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at", "this", "but", "his", "by", "from", "they", "we", "say", "her", "she", "or", "an", "will", "my", "one", "all", "would", "there", "their", "what", "so", "up", "out", "if", "about", "who", "get", "which", "go", "me", "when", "make", "can", "like", "time", "no", "just", "him", "know", "take", "people", "into", "year", "your", "good", "some", "could", "them", "see", "other", "than", "then", "now", "look", "only", "come", "its", "over", "think", "also", "back", "after", "use", "two", "how", "our", "work", "first", "well", "way", "even", "new", "want", "because", "any", "these", "give", "day", "most", "us"];

        let username = '';
        let currentText = [];
        let currentPosition = 0;
        let visibleStartIndex = 0;
        let startTime = null;
        let timerInterval = null;
        let timeLeft = 60;
        let correctChars = 0;
        let totalChars = 0;
        let isTestActive = false;
        let wpmHistory = [];
        let testHistory = [];
        let lastWPM = 0;
        let recentWPMs = [];
        let testDuration = 60; 
        
        // Get references to DOM elements
        const body = document.body; // NEW
        const mainContainer = document.getElementById('mainContainer'); // NEW ID
        const usernameModal = document.getElementById('usernameModal');
        const usernameInput = document.getElementById('usernameInput');
        const resultsModal = document.getElementById('resultsModal');
        const timerSlider = document.getElementById('timerSlider');
        const timerLabel = document.getElementById('timerLabel');
        const restartBtn = document.getElementById('restartBtn');
        const tryNextBtn = document.getElementById('tryNextBtn');
        const closeResultsBtn = document.getElementById('closeResultsBtn');
        const typingArea = document.getElementById('typingArea');
        // NEW Elements
        const goodbyeDashboardContainer = document.getElementById('goodbyeDashboardContainer');
        const goodbyeText = document.getElementById('goodbyeText');
        const historyChartCanvas = document.getElementById('historyChartCanvas');


        function generateWords(count) {
            let result = [];
            for (let i = 0; i < count; i++) {
                result.push(words[Math.floor(Math.random() * words.length)]);
            }
            return result;
        }

        function saveUsername() {
            const value = usernameInput.value.trim();
            if (value) {
                username = value;
                localStorage.setItem('BearPawTypeUsername', username);
                usernameModal.classList.add('hidden');
                document.getElementById('sidebarTitle').textContent = username + "'s Scores";
                loadHistory();
                usernameInput.blur(); 
            } else {
                alert('Please enter a username!');
            }
        }

        function loadUsername() {
            const saved = localStorage.getItem('BearPawTypeUsername');
            if (saved) {
                username = saved;
                usernameModal.classList.add('hidden');
                document.getElementById('sidebarTitle').textContent = username + "'s Scores";
            }
        }

        function getVisibleWords() {
            // Render up to 80 words from the starting index
            return currentText.slice(visibleStartIndex, visibleStartIndex + 80);
        }

        function initTest() {
            if (timerInterval) clearInterval(timerInterval);
            
            currentText = generateWords(100);
            currentPosition = 0;
            visibleStartIndex = 0;
            correctChars = 0;
            totalChars = 0;
            timeLeft = testDuration; 
            isTestActive = false;
            wpmHistory = [];
            recentWPMs = [];
            lastWPM = 0;
            
            document.getElementById('timer').textContent = testDuration;
            document.getElementById('wpm').textContent = '0';
            document.getElementById('accuracy').textContent = '100%';
            resultsModal.classList.add('hidden'); 
            document.getElementById('speedMessage').textContent = 'Start typing to see your speed!';
            document.getElementById('speedBar').style.width = '0%';
            document.getElementById('speedBar').classList.remove('burst');
            document.getElementById('speedMessage').classList.remove('burst');
            
            restartBtn.textContent = 'Start Test';
            timerSlider.disabled = false; 
            
            // NEW: Ensure scroll is blocked when not active, and cleanup goodbye mode
            body.classList.add('scroll-blocked');
            body.classList.remove('goodbye-mode');
            mainContainer.classList.remove('fly-away');
            mainContainer.style.display = ''; // Reset display style
            goodbyeDashboardContainer.classList.remove('active');
            
            renderText();
            loadHistory();
        }

        function renderText() {
            typingArea.innerHTML = '';
            
            const visibleWords = getVisibleWords();
            
            let charIndex = 0;
            for (let i = 0; i < visibleStartIndex; i++) {
                // Account for words that are no longer visible, plus the space after each
                charIndex += currentText[i].length + 1;
            }
            
            visibleWords.forEach((word) => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word';
                
                word.split('').forEach((char) => {
                    const letterSpan = document.createElement('span');
                    letterSpan.className = 'letter';
                    letterSpan.textContent = char;
                    letterSpan.dataset.index = charIndex;
                    
                    if (charIndex < currentPosition) {
                        letterSpan.classList.add('correct');
                    } else if (charIndex === currentPosition) {
                        letterSpan.classList.add('current');
                    }
                    
                    wordSpan.appendChild(letterSpan);
                    charIndex++;
                });
                
                // Add a space element (but not after the very last word)
                if (typingArea.children.length < visibleWords.length) {
                    const spaceSpan = document.createElement('span');
                    spaceSpan.className = 'letter';
                    spaceSpan.textContent = ' ';
                    spaceSpan.dataset.index = charIndex;
                    
                    if (charIndex < currentPosition) {
                         spaceSpan.classList.add('correct');
                    } else if (charIndex === currentPosition) {
                        spaceSpan.classList.add('current');
                    }
                    
                    wordSpan.appendChild(spaceSpan);
                    charIndex++;
                }

                typingArea.appendChild(wordSpan);
            });
            
            // Final check to ensure the cursor is on screen immediately after render
            if (currentPosition > 0) {
                 const currentLetterEl = document.querySelector(`[data-index="${currentPosition}"]`) || document.querySelector(`[data-index="${currentPosition - 1}"]`);
                 if (currentLetterEl && !currentLetterEl.classList.contains('current')) {
                    currentLetterEl.classList.add('current');
                 }
            }
        }

        // Corrected Autoscroll Logic
        function updateVisibleText() {
            // Find the currently focused letter element
            const currentLetterEl = document.querySelector(`.letter.current`);
            if (!currentLetterEl) return;
            
            const visibleWordElements = typingArea.querySelectorAll('.word');
            if (visibleWordElements.length === 0) return;

            const firstWordTop = visibleWordElements[0].offsetTop;

            // 1. Find the starting index of the second line
            let startWordIndexOfSecondLine = 0; 
            for (let i = 1; i < visibleWordElements.length; i++) {
                // Check if the current word's line top is greater than the first word's line top
                if (visibleWordElements[i].offsetTop > firstWordTop) {
                    startWordIndexOfSecondLine = i;
                    break;
                }
            }

            if (startWordIndexOfSecondLine === 0) return; // Only one line is visible

            // 2. Find the starting index of the third line (this is our scroll trigger point)
            const secondLineTop = visibleWordElements[startWordIndexOfSecondLine].offsetTop;
            let startWordIndexOfThirdLine = 0;
            for (let i = startWordIndexOfSecondLine + 1; i < visibleWordElements.length; i++) {
                // Check if the current word's line top is greater than the second line's line top
                if (visibleWordElements[i].offsetTop > secondLineTop) {
                    startWordIndexOfThirdLine = i;
                    break;
                }
            }

            // 3. Check if the current cursor is on or past the third visible line
            const currentCursorTop = currentLetterEl.offsetTop;
            
            // Trigger scroll if the third line starts (startWordIndexOfThirdLine > 0) AND
            // the cursor is vertically positioned on or after the start of that third line.
            if (startWordIndexOfThirdLine > 0 && currentCursorTop >= visibleWordElements[startWordIndexOfThirdLine].offsetTop) {
                
                // SCROLL TRIGGERED: Shift the visible start index by the number of words in the first line
                visibleStartIndex += startWordIndexOfSecondLine;
                renderText();
            }

            // Load more text check: If the user is nearing the end of the currently generated text, generate more.
            const fullTextLength = currentText.join(' ').length;
            if (currentPosition >= fullTextLength - 50) {
                currentText = currentText.concat(generateWords(30));
                // Only re-render if a scroll wasn't already triggered (to avoid double render)
                if (!(startWordIndexOfThirdLine > 0 && currentCursorTop >= visibleWordElements[startWordIndexOfThirdLine].offsetTop)) {
                    renderText();
                }
            }
        }

        function updateSpeedMeter() {
            if (!isTestActive || totalChars === 0) return;

            const currentWPM = calculateWPM();
            recentWPMs.push(currentWPM);
            if (recentWPMs.length > 5) recentWPMs.shift();
            
            const avgRecent = recentWPMs.reduce((a, b) => a + b, 0) / recentWPMs.length;
            const maxWPM = 120;
            const percentage = Math.min((avgRecent / maxWPM) * 100, 100);
            
            const speedBar = document.getElementById('speedBar');
            const speedMessage = document.getElementById('speedMessage');
            
            speedBar.style.width = percentage + '%';
            
            let message = '';
            let isBurst = false;
            
            if (avgRecent >= 100) {
                message = 'üî• LEGENDARY SPEED! üî•';
                isBurst = true;
            } else if (avgRecent >= 80) {
                message = '‚ö° BLAZING FAST! ‚ö°';
                isBurst = true;
            } else if (avgRecent >= 60) {
                message = 'üöÄ GREAT SPEED! üöÄ';
                isBurst = true;
            } else if (avgRecent >= 40) {
                message = 'üí® Nice pace!';
            } else if (avgRecent >= 20) {
                message = 'üêª Keep going!';
            } else {
                message = 'Warm up those paws!';
            }
            
            speedMessage.textContent = message;
            
            if (isBurst && !speedBar.classList.contains('burst')) {
                speedBar.classList.add('burst');
                speedMessage.classList.add('burst');
                setTimeout(() => {
                    speedBar.classList.remove('burst');
                    speedMessage.classList.remove('burst');
                }, 500);
            } else if (!isBurst) {
                speedBar.classList.remove('burst');
                speedMessage.classList.remove('burst');
            }
            
            lastWPM = currentWPM;
        }

        function startTest() {
            if (!isTestActive) {
                isTestActive = true;
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 100); 
                restartBtn.textContent = 'Restart';
                timerSlider.disabled = true; 
                // NEW: Remove scroll block when test starts
                body.classList.remove('scroll-blocked');
            }
        }

        function updateTimer() {
            const elapsed = (Date.now() - startTime) / 1000;
            // Use testDuration here
            timeLeft = Math.max(0, testDuration - elapsed); 
            document.getElementById('timer').textContent = Math.ceil(timeLeft);
            
            if (timeLeft <= 0) {
                if(isTestActive) {
                    endTest();
                }
            }
        }

        function calculateWPM() {
            const elapsed = (Date.now() - startTime) / 1000 / 60;
            if (elapsed <= 0) return 0;
            const wpm = Math.round((correctChars / 5) / elapsed);
            return wpm;
        }

        function updateStats() {
            const wpm = calculateWPM();
            const accuracy = totalChars > 0 ? Math.round((correctChars / totalChars) * 100) : 100;
            
            document.getElementById('wpm').textContent = wpm;
            document.getElementById('accuracy').textContent = accuracy + '%';
            
            wpmHistory.push({ time: testDuration - timeLeft, wpm: wpm });
            updateSpeedMeter();
        }

        function endTest() {
            clearInterval(timerInterval);
            isTestActive = false;
            
            const finalWPM = calculateWPM();
            const finalAccuracy = totalChars > 0 ? Math.round((correctChars / totalChars) * 100) : 100;
            
            const testResult = {
                date: new Date().toISOString(),
                wpm: finalWPM,
                accuracy: finalAccuracy,
                wpmHistory: [...wpmHistory]
            };
            
            testHistory.unshift(testResult);
            // We only keep the last 10 for the sidebar, but all for the historical chart
            // if (testHistory.length > 10) testHistory.pop(); 
            
            saveHistory();
            loadHistory();
            showResultsModal(finalWPM, finalAccuracy); 

            restartBtn.textContent = 'Restart';
            timerSlider.disabled = false;
            // NEW: Add scroll block after test ends
            body.classList.add('scroll-blocked');
        }
        
        function showResultsModal(wpm, accuracy) {
            document.getElementById('finalWPM').textContent = wpm;
            document.getElementById('finalAccuracy').textContent = accuracy + '%';
            resultsModal.classList.remove('hidden');
            showChart();
        }

        function showChart() {
            const ctx = document.getElementById('modalProgressChart').getContext('2d');
            
            if (window.progressChart) {
                window.progressChart.destroy();
            }
            
            // Filter WPM history to 1-second intervals for cleaner labels
            const filteredHistory = wpmHistory.filter((_, i) => Math.ceil(wpmHistory[i].time) !== Math.ceil(wpmHistory[i-1]?.time));
            
            window.progressChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: filteredHistory.map(d => (testDuration - d.time).toFixed(0) + 's'),
                    datasets: [{
                        label: 'WPM',
                        data: filteredHistory.map(d => d.wpm),
                        borderColor: '#4a9eff',
                        backgroundColor: 'rgba(74, 158, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        },
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        }
                    }
                }
            });
        }
        
        let historicalWPMChart = null; // To store chart instance
        function showHistoricalWPMChart() {
            if (historicalWPMChart) {
                historicalWPMChart.destroy();
            }
            
            // Reverse history so oldest is first for proper chart plotting (left to right)
            const reversedHistory = [...testHistory].reverse();

            const labels = reversedHistory.map((_, index) => `Test ${index + 1}`);
            const data = reversedHistory.map(d => d.wpm);
            
            // Create a specific color array for points: green for the latest (last element in reversed array)
            const pointBackgroundColors = data.map((_, index) => 
                index === data.length - 1 ? '#00ff88' : '#4a9eff'
            );
            
            historicalWPMChart = new Chart(historyChartCanvas.getContext('2d'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'WPM Score',
                        data: data,
                        borderColor: '#4a9eff',
                        backgroundColor: 'rgba(74, 158, 255, 0.1)',
                        pointBackgroundColor: pointBackgroundColors, // Apply custom colors
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        },
                        title: {
                            display: true,
                            text: 'WPM Trend Across All Tests',
                            color: '#fff'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        },
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        }
                    }
                }
            });
        }

        function saveHistory() {
            const data = { testHistory };
            localStorage.setItem('typingTestHistory_' + username, JSON.stringify(data));
        }

        function loadHistory() {
            const saved = localStorage.getItem('typingTestHistory_' + username);
            if (saved) {
                const data = JSON.parse(saved);
                // Keep all history for the chart, but only use the most recent 10 for sidebar display.
                testHistory = (data.testHistory || []); 
            }
            renderHistory();
        }

        function renderHistory() {
            const historyList = document.getElementById('historyList');
            
            if (testHistory.length === 0) {
                historyList.innerHTML = '<div class="no-history">No previous tests yet.<br>Start typing to record your first score!</div>';
                return;
            }
            
            // Only show the most recent 10 in the sidebar list
            const sidebarHistory = testHistory.slice(0, 10);
            
            historyList.innerHTML = sidebarHistory.map(test => {
                const date = new Date(test.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                return `
                    <div class="history-item">
                        <div class="history-date">${dateStr}</div>
                        <div class="history-stats">
                            <span class="history-wpm">${test.wpm} WPM</span>
                            <span class="history-accuracy">${test.accuracy}% ACC</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        document.addEventListener('keydown', (e) => {
            if (!usernameModal.classList.contains('hidden') || !resultsModal.classList.contains('hidden')) {
                return;
            }
            
            if (!isTestActive && e.key.length === 1) {
                startTest();
            }
            
            if (!isTestActive) return;
            
            if (e.key.length === 1 || e.key === ' ') {
                e.preventDefault();
                
                const fullText = currentText.join(' ') + ' ';
                const expectedChar = fullText[currentPosition];
                
                totalChars++;
                
                if (e.key === expectedChar) {
                    correctChars++;
                    const letterEl = document.querySelector(`[data-index="${currentPosition}"]`);
                    if (letterEl) {
                        letterEl.classList.remove('current');
                        letterEl.classList.add('correct');
                    }
                    
                    currentPosition++;
                    
                    if (currentPosition >= fullText.length) {
                        endTest();
                        return;
                    }

                    const nextLetterEl = document.querySelector(`[data-index="${currentPosition}"]`);
                    if (nextLetterEl) {
                        // Remove 'current' from the previous letter if it was a space/end of word
                        const prevLetterEl = document.querySelector(`[data-index="${currentPosition - 1}"]`);
                        if(prevLetterEl) prevLetterEl.classList.remove('current');
                        
                        nextLetterEl.classList.add('current');
                    }
                    
                    // Crucial: call scrolling logic after moving position
                    updateVisibleText(); 
                    
                } else {
                    const letterEl = document.querySelector(`[data-index="${currentPosition}"]`);
                    if (letterEl) {
                        letterEl.classList.add('incorrect');
                        setTimeout(() => {
                            letterEl.classList.remove('incorrect');
                        }, 500);
                    }
                }
                
                updateStats();
            }
        });
        
        // NEW: Event listener to block manual scrolling while the body has the 'scroll-blocked' class
        document.addEventListener('wheel', (e) => {
            if (body.classList.contains('scroll-blocked')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
             if (body.classList.contains('scroll-blocked')) {
                e.preventDefault();
            }
        }, { passive: false });


        restartBtn.addEventListener('click', initTest);
        
        tryNextBtn.addEventListener('click', () => {
            initTest(); 
        });

        // MODIFIED FIX: Close button listener now triggers the "fly-away" animation and shows the goodbye message/dashboard
        closeResultsBtn.addEventListener('click', () => {
            resultsModal.classList.add('hidden'); // Hide modal immediately
            
            // 1. Prepare and activate the goodbye message
            goodbyeText.textContent = `SEE YOU LATER, ${username.toUpperCase()}! üêª`;
            goodbyeDashboardContainer.classList.add('active');
            
            // 2. Start the animation on the main content
            mainContainer.classList.add('fly-away'); 
            
            // 3. Enable scrolling on the body and change mode immediately
            body.classList.remove('scroll-blocked');
            body.classList.add('goodbye-mode');
            
            // 4. Render the historical chart if there is history
            if (testHistory.length > 0) {
                 showHistoricalWPMChart();
            }
            
            // **CRITICAL FIX FOR INFINITE SCROLLING:** Wait for animation to finish (0.8s), 
            // then remove the main container from the document flow and scroll directly to the dashboard.
            setTimeout(() => {
                // Remove the container from the layout so its height no longer counts
                mainContainer.style.display = 'none'; 
                
                // Use scrollIntoView which targets the element directly, stabilizing the scroll.
                goodbyeDashboardContainer.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start' // Scroll until the element is at the top of the view
                });
            }, 800); // 800ms matches the flyAway CSS animation duration
        });

        // Setup username modal
        const usernameBtn = document.getElementById('saveUsernameBtn');
        
        usernameBtn.onclick = saveUsername;
        
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveUsername();
            }
        });
        
        // Timer Slider Logic
        timerSlider.addEventListener('input', () => {
            testDuration = parseInt(timerSlider.value);
            
            const minutes = Math.floor(testDuration / 60);
            const seconds = testDuration % 60;
            let displayTime = '';
            
            if (minutes > 0) {
                displayTime += `${minutes}m`;
            }
            if (seconds > 0 || testDuration === 0) {
                displayTime += ` ${seconds}s`;
            }
            
            timerLabel.textContent = `Test Duration: ${displayTime.trim()}`;
            
            if (!isTestActive) {
                document.getElementById('timer').textContent = testDuration;
            }
        });


        loadUsername();
        initTest();
    </script>
</body>
</html>
